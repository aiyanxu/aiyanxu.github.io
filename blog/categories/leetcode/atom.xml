<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Leetcode | be a better man]]></title>
  <link href="http://aiyanxu.github.io/blog/categories/leetcode/atom.xml" rel="self"/>
  <link href="http://aiyanxu.github.io/"/>
  <updated>2015-04-24T15:57:44+08:00</updated>
  <id>http://aiyanxu.github.io/</id>
  <author>
    <name><![CDATA[Aiyanxu]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Happy Number]]></title>
    <link href="http://aiyanxu.github.io/blog/2015/04/24/happy-number/"/>
    <updated>2015-04-24T15:38:59+08:00</updated>
    <id>http://aiyanxu.github.io/blog/2015/04/24/happy-number</id>
    <content type="html"><![CDATA[<p>Write an algorithm to determine if a number is &ldquo;happy&rdquo;.</p>

<p>A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.</p>

<p>Example: 19 is a happy number</p>

<p>1<sup>2</sup> + 9<sup>2</sup> = 82<br/>
8<sup>2</sup> + 2<sup>2</sup> = 68<br/>
6<sup>2</sup> + 8<sup>2</sup> = 100<br/>
1<sup>2</sup> + 0<sup>2</sup> + 0<sup>2</sup> = 1</p>

<p>我们先分析下算法的终止条件<br/>
成功的情况是计算结果等于1<br/>
失败的情况是陷入了死循环</p>

<p>针对失败的情况，我们可以使用一个Set来记录之前出现过的计算结果，如果出现了重复的计算值，则数字不是Happy Number</p>

<p>在计算的过程中需要求解数字每位的平方值，我们可以从数学角度分解出数字每一位的值，这里为了简单，我直接将数字转化成了字符串，然后遍历字符串的每一位时再将它转化成数字计算。</p>

<p>代码为了简便，使用Python实现，这也可能规避了可能出现的数值溢出的情况</p>

<pre><code class="Python">class Solution:
    def isHappy(self, n):
        used = set()
        while n != 1 and not n in used:
            used.add(n)
            next = 0
            s = str(n)
            for i in range(len(s)):
                next += int(s[i]) * int(s[i])
            n = next
        if n == 1:
            return True
        return False
</code></pre>

<p>这个是LeetCode上新的题目，现在还不清楚是否有更加高效的算法，或者这个问题是否有数学解</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Second Highest Salary]]></title>
    <link href="http://aiyanxu.github.io/blog/2015/04/24/second-highest-salary/"/>
    <updated>2015-04-24T15:00:09+08:00</updated>
    <id>http://aiyanxu.github.io/blog/2015/04/24/second-highest-salary</id>
    <content type="html"><![CDATA[<p>Write a SQL query to get the second highest salary from the Employee table.<br/>
If there is no second highest salary,then the query should return <code>null</code></p>

<p>需要查询第二高的薪水，对于有位置要求的查询，我首先想到了<code>LIMIT</code>关键字，题目同时要求去重，需要使用<code>DISTINCT</code>关键字</p>

<pre><code class="SQL">SELECT DISTINCT Salary FROM Employee ORDER BY Salary DESC LIMIT 1,1;
</code></pre>

<p>上面语句的问题是当结果为空时，返回的是<code>[]</code>,而不是<code>null</code>,解决办法是嵌套SELECT语句</p>

<pre><code class="SQL">SELECT (SELECT DISTINCT Salary FROM Employee ORDER BY Salary DESC LIMIT 1,1);
</code></pre>

<p>对于顺序问题的查询，我们也倾向于使用MAX，MIN这些统计函数，当然此问题还可以使用子查询完成，配合使用MAX函数，代码如下</p>

<pre><code class="SQL">SELECT MAX(Salary)
FROM Employee
WHERE Salary &lt; (SELECT MAX(Salary) FROM Employee);
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Remove Linked List Elements]]></title>
    <link href="http://aiyanxu.github.io/blog/2015/04/24/remove-linked-list-elements/"/>
    <updated>2015-04-24T14:38:12+08:00</updated>
    <id>http://aiyanxu.github.io/blog/2015/04/24/remove-linked-list-elements</id>
    <content type="html"><![CDATA[<p>Remove all elements from a linked list of integers that have value val.</p>

<p>Example<br/>
Given: 1&ndash;>2&ndash;>6&ndash;>3&ndash;>4&ndash;>5&ndash;>6,val=6<br/>
return: 1&ndash;>2&ndash;>3&ndash;>4&ndash;>5</p>

<p>这道题难度不大，属于在列表中删除特定元素的变种题。需要注意的点一是列表为空的情况，二是头元素需要删除以及删除头元素导致列表为空的情况。直接上代码：</p>

<pre><code class="Java">public class Solution {
    public ListNode removeElements(ListNode head, int val) {
        if(head == null)
            return null;
        while (head != null &amp;&amp; head.val == val){
            head = head.next;
        }
        if(head == null)
            return null;
        ListNode pre = head,p = head;
        while(p != null){
            if(p.val == val){
                pre.next = p.next;
            }
            else{
                pre = p;
            }
            p = p.next;
        }
        return head;
    }
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[LeetCode 之 Single Number]]></title>
    <link href="http://aiyanxu.github.io/blog/2015/04/24/single-number/"/>
    <updated>2015-04-24T13:36:08+08:00</updated>
    <id>http://aiyanxu.github.io/blog/2015/04/24/single-number</id>
    <content type="html"><![CDATA[<p>Given an array of integers,every element appears twice except for one.Find that single one</p>

<p>Note:<br/>
Your algorithm should have a linear runtime complexity.</p>

<p>线性运行时间说明我们最好遍历一次数组就得到结果。在遍历数组的同时，我们需要记住已经出现的数字，这里我们可以使用一个额外的字典。第一版代码如下</p>

<pre><code class="Java">public class Solution {
    public int singleNumber(int[] A) {
        int res = 0;
        Map&lt;Integer,Integer&gt; tmp = new HashMap&lt;Integer,Integer&gt;();

        for(int i=0; i&lt;A.length; i++){
            if(!tmp.containsKey(A[i]))
                tmp.put(A[i], 1);
            else
                tmp.put(A[i], tmp.get(A[i])+1);
        }

        for(int key : tmp.keySet()){
            if(tmp.get(key) == 1)
                res = key;
        }
        return res;
    }
}
</code></pre>

<p>上面的代码实现了只遍历一次数组，但之后我们还遍历了一次tmp字典才得到了最终结果，同时我们只需要找出Single Number，是否可以不记录数字出现的具体次数。修改后的第二版代码：</p>

<pre><code class="Java">public class Solution {
    public int singleNumber(int[] A) {
        HashSet&lt;Integer&gt; tmp = new HashSet&lt;Integer&gt;();
        for(int i=0;i&lt;A.length;i++){
            if(tmp.contains(A[i]))
                tmp.remove(A[i]);
            else
                tmp.add(A[i]);
        }
        return (Integer)(tmp.toArray()[0]);
    }
}
</code></pre>

<p>在新一版的代码中我们将Hash更换成了Set，因为数组中只有一个Single Number，最后我们只需将Set转换为数组，取出第一个元素即可。</p>

<p>在前面的实现中，我们都使用到了额外的数据结构，如何做到不使用额外空间呢?</p>

<p>在数理逻辑中，我们可以通过异或操作来判定两个数字是否相同。相同的两个数字进行按位异或结果为0，而一个数字与0按位异或结果仍是它之身。根据以上分析，第三版代码如下：</p>

<pre><code class="Java">public class Solution {
     public int singleNumber(int[] A){
        int res = 0;
        for(int val : A)
            res = res ^ val;
        return res;
    }
}
</code></pre>
]]></content>
  </entry>
  
</feed>
