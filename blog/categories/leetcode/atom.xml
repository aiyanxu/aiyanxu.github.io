<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Leetcode | be a better man]]></title>
  <link href="http://aiyanxu.github.io/blog/categories/leetcode/atom.xml" rel="self"/>
  <link href="http://aiyanxu.github.io/"/>
  <updated>2015-04-24T14:21:58+08:00</updated>
  <id>http://aiyanxu.github.io/</id>
  <author>
    <name><![CDATA[Aiyanxu]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[LeetCode 之 Single Number]]></title>
    <link href="http://aiyanxu.github.io/blog/2015/04/24/single-number/"/>
    <updated>2015-04-24T13:36:08+08:00</updated>
    <id>http://aiyanxu.github.io/blog/2015/04/24/single-number</id>
    <content type="html"><![CDATA[<p>Given an array of integers,every element appears twice except for one.Find that single one</p>

<p>Note:<br/>
Your algorithm should have a linear runtime complexity.</p>

<p>线性运行时间说明我们最好遍历一次数组就得到结果。在遍历数组的同时，我们需要记住已经出现的数字，这里我们可以使用一个额外的字典。第一版代码如下</p>

<pre><code class="Java">public class Solution {
    public int singleNumber(int[] A) {
        int res = 0;
        Map&lt;Integer,Integer&gt; tmp = new HashMap&lt;Integer,Integer&gt;();

        for(int i=0; i&lt;A.length; i++){
            if(!tmp.containsKey(A[i]))
                tmp.put(A[i], 1);
            else
                tmp.put(A[i], tmp.get(A[i])+1);
        }

        for(int key : tmp.keySet()){
            if(tmp.get(key) == 1)
                res = key;
        }
        return res;
    }
}
</code></pre>

<p>上面的代码实现了只遍历一次数组，但之后我们还遍历了一次tmp字典才得到了最终结果，同时我们只需要找出Single Number，是否可以不记录数字出现的具体次数。修改后的第二版代码：</p>

<pre><code class="Java">public class Solution {
    public int singleNumber(int[] A) {
        HashSet&lt;Integer&gt; tmp = new HashSet&lt;Integer&gt;();
        for(int i=0;i&lt;A.length;i++){
            if(tmp.contains(A[i]))
                tmp.remove(A[i]);
            else
                tmp.add(A[i]);
        }
        return (Integer)(tmp.toArray()[0]);
    }
}
</code></pre>

<p>在新一版的代码中我们将Hash更换成了Set，因为数组中只有一个Single Number，最后我们只需将Set转换为数组，取出第一个元素即可。</p>

<p>在前面的实现中，我们都使用到了额外的数据结构，如何做到不使用额外空间呢?</p>

<p>在数理逻辑中，我们可以通过异或操作来判定两个数字是否相同。相同的两个数字进行按位异或结果为0，而一个数字与0按位异或结果仍是它之身。根据以上分析，第三版代码如下：</p>

<pre><code class="Java">public class Solution {
     public int singleNumber(int[] A){
        int res = 0;
        for(int val : A)
            res = res ^ val;
        return res;
    }
}
</code></pre>
]]></content>
  </entry>
  
</feed>
